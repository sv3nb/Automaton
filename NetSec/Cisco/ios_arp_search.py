#! /usr/bin/env python3
# code generated by regex101.com

import re
import json

regex = re.compile(r"(?P<protocol>\w+)\s+(?P<address>[\d\.\:]+)\s+(?P<age>-|\w+)\s+(?P<mac>\w+.\w+.\w+)\s+(?P<type>\w+)\s+(?P<interface>\w+\d\/\d)")

test_str = ("Protocol  Address          Age (min)  Hardware Addr   Type   Interface\n"
	"    Internet  1.1.1.2               243   ca01.09dc.001c  ARPA   GigabitEthernet1/0\n"
	"    Internet  172.16.100.1            -   ca03.1149.001c  ARPA   GigabitEthernet1/0\n"
	"    Internet  172.16.100.2          259   ca01.09dc.001c  ARPA   GigabitEthernet1/0\n"
	"    Internet  192.168.107.140       144   000c.2976.34c8  ARPA   FastEthernet0/0 ")

# when storing our results in a new list we can display duplicate macs in the arp table when they are mapped to multiple IPs

def arp_list(regex, test_str):
	regex = regex
	test_str = test_str
	mylist = []
	for line in test_str.splitlines():
		line = line.strip()
		m = regex.match(line)
		if m:
			group1 = m.groupdict() # every line becomes a dict with multiple key, value pairs
			mylist.append(group1) # nest each dict in a list
	for dict in mylist:
		if dict['mac'] == 'ca03.1149.001c':
			print(str(dict['mac']) + " lives on interface " + str(dict['interface']) )

arp_list(regex, test_str)
# when using a dictionary  entries like ca01.09dc.001c are returned only once even if they occur multiple times.

def arp_dict(regex, test_str):
	regex = regex
	test_str = test_str
	mydict = {}
	for line in test_str.splitlines():
		line = line.strip()
		m = regex.match(line)
		if m:
			group = m.groupdict()
			mac_address = group.get('mac')  # we retrieve the MAC and use it as the key for our new nested dictionary
			mydict.update({mac_address: group})
	for mac, entry in mydict.items():
			print('mac_address: ' + mac + ' lives on intf ' + entry['interface'] )

arp_dict(regex, test_str)
